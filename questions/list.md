* Вопросы и ответы

+ С помощью каких методов можно найти DOM-элементы на странице?
>getElementByClassName , getElementById , querySelector , querySelectorAll , getElementByTagName , getElementsByName (достаточно 2-3 способа из этого списка).

+ С помощью каких методов можно добавлять и удалять DOM-элементы?
> appendChild и removeChild (плюсом будет, если кандидат вспомнил о replaceChild , insertBefore или неявном изменении элементов с помощью innerHTML ).

+ Каким образом можно управлять выравниванием текста в блоке?
> С помощью CSS свойства text-align .

+ Назовите несколько способов сделать жирное начертание шрифта.
> С помощью тегов b или strong , с помощью CSS свойства font-weight со значением bold .

+ Чем отличается позиционирование fixed от absolute ?
> Фиксированное в отличие от абсолютного привязывается к точке на экране и не меняет своего положения при прокрутке веб-страницы.

+ Какие существуют значения CSS свойства display ?
> block , inline-block , inline , flex и grid , none (возможно, кандидат вспомнит про table и table-* , list-item ).

+ Какие существуют единицы измерения в CSS?
> Абсолютные: px . Относительные: em , rem , % . Относительно экрана: vw , vh . Достаточно, если кандидат назовёт по одной единице из каждой группы.
____________________________________
+ Как назначить обработчик события на элемент?
> С помощью addEventListener . C помощью HTML-атрибута on<событие> (например, onclick ). С помощью свойства вида on<событие> у DOM-элемента (например, elem.onclick ).
+ Опишите основной принцип всплытия событий в DOM.
> При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, и так далее, вверх по цепочке вложенности (т.е. событие "всплывает" снизу вверх по элементам в DOM-дереве).
____________________________________
+ Назовите основные типы данных в JavaScript.
> Минимум: number , string , boolean , object . Хорошо, если не забыл про null и undefined .

+ Чем отличается оператор "три равно" ( === ) от оператора "два равно" ( == )?
> === сравнивает два объекта без приведения типа ( == сравнивает с приведением типа).

+ Назовите два способа явного преобразования значения к типу boolean .
> Двойное логическое отрицание !!value или вызов конструктора Boolean(value) .
____________________________________
+ С помощью какого метода можно скопировать участок массива?
> slice .

+ Какие методы массива позволяют итерироваться по его элементам?
> Минимум: forEach , map . Хорошо, если кандидат назовёт reduce/reduceRight , every/some , find , filter .

+ Каким образом можно удалить элементы из массива?
> С помощью методов pop (из начала массива) и shift (с конца массива), с помощью оператора delete. Хорошо, если кандидат скажет, что можно использовать метод splice для удаления элементов из середины массива.
____________________________________
+ Как можно перебрать ключи (свойства) объекта?
> С помощью цикла for...in .

+ Как проверить наличие ключа (свойства) в объекте?
> С помощью оператора in (плюс, если кандидат упомянет о проверке hasOwnProperty ). С помощью сравнения значения свойства с undefined .
____________________________________
+ С помощью какого метода можно убрать лишние пробелы в начале и в конце строки?
> trim .

+ С помощью какого метода можно изменить символ в строке?
> Содержимое строк в JavaScript изменять нельзя.
____________________________________
+ Методу массива sort в качестве аргумента можно передать функцию. Что это за функция и зачем она нужна?
> Это функция-компаратор. Она нужна для того, чтобы иметь возможность сортировать произвольные элементы, а не только строки.

+ Методу массива reduce помимо коллбэка можно передать один необязательный аргумент. Что это за аргумент и зачем он нужен?
> Аргумент задаёт начальное значение ( initialValue ) для перебора. Если он задан, то на первом вызове коллбэка предыдущее значение будет равно этому аргументу. Иначе начальным значением становится первый элемент массива, а перебор начинается со второго.
____________________________________
+ Каким образом можно привязать функцию к определённому контексту?
> С помощью функции-обёртки, с помощью метода bind .

+ С помощью каких методов можно вызвать функцию с произвольным контекстом?
> apply и call . apply работает аналогично call , но принимает массив аргументов вместо списка.
____________________________________
+ Правда ли, что функции в JavaScript создают новую область видимости?
> Да.

____________________________________
+ Есть ли гарантия, что переданный в функцию setTimeout коллбэк будет выполнен ровно через указанное время?
> В реальности срабатывания таймера может быть позже, чем назначено. Например, если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.

+ В чём отличие вызова setInterval и рекурсивного вызова setTimeout с одним и тем же интервалом?
> Рекурсивный setTimeout гарантирует паузу между вызовами, а setInterval – нет. Например, если функция выполняется дольше, чем пауза setInterval , то вызовы будут происходить без перерыва.
____________________________________
+ Какая асимптотическая сложность оптимального алгоритма поиска наибольшего элемента в неотсортированном массиве?
> Линейная – O(n)

+ Какая асимптотическая сложность бинарного поиска в отсортированном массиве?
> Логарифмическая – O(log(n)) .
____________________________________
+ Зачем нужна директива "use strict" ?
> Включает строгий режим интерпретации (режим полного соответствия современному стандарту).

+ Repaint (Перерисовка)
> Возникает в случаях, если были изменены визуальные составляющие элемента, не затрагивающие его разметку. К примеру, opacity, background-color, visibility и outline. Repaint достаточно затратная штука с точки зрения производительности, т.к. браузер должен проверить видимость всех узлом DOM–под одним измененным элементом могут стать видимыми еще один или два.
  
+ Reflow (Перекомпановка)
> Reflow же еще больше воздействуют на производительность. Во время этого процесса происходит перерасчет позиций и размеров всех элементов, что приводит к полной или частичной повторной отрисовке страницы. Изменения в одном элементе могут повлиять на все дочерние, родительские или смежные элементы.
Оба процесса блокируют браузер; и не пользователь, и не ваше веб-приложение не смогут ничего сделать во время reflow и repaint. В крайних случаях CSS эффекты могут затормозить выполнение JavaScript’а. Это одна из причин, почему вы сталкиваетесь с дергающейся прокруткой страницы и неотзывчивым интерфейсом.

>> Полезно знать, в каких случаях запускается reflow: Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
  Изменение содержимого, в т.ч. текста в полях форм;
  Расчёт или изменение CSS-свойств;
  Добавление, удаление таблиц стилей;
  Манипуляции с атрибутом «class»;
  Манипуляции с окном браузера — изменения размеров, прокрутка;
  Активация псевдо-классов (например, :hover).

+ MicroTask and MacroTasks
>> Задачи берутся из очереди задач.
   Задача из очереди задач — макрозадача != микрозадача.
   Все микрозадачи обрабатываются, пока не очистится очередь, и только после этого начинается следующий цикл макрозадачи.
   Микрозадачи могут ставить в очередь другие микрозадачи, и все они должны быть исполнены в пределах одного цикла.
   Рендеринг UI происходит после исполнения микрозадач.

    console.log('script start');
    setTimeout(function() {
      console.log('setTimeout');
    }, 0);
    Promise.resolve().then(function() {
      console.log('promise1');
    }).then(function() {
      console.log('promise2');
    });
    console.log('script end');

    script start
    script end
    promise1
    promise2
    setTimeout
+  Различия монолитных и атомарных SPA
>> Монолитные это подход, когда в приложении все связанно и едино(все в одной репе), а атомарном подходе это когда какие части функционала или страниц выносятся в отдельные пакеты и можно переиспользовать
